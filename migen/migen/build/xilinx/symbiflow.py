# This file is Copyright (c) 2020 Antmicro <www.antmicro.com>
# This file is Copyright (c) 2020 Florent Kermarrec <florent@enjoy-digital.fr>
# License: BSD

import os
import subprocess
import sys
import math
import re
import warnings
import shlex

from migen.fhdl.structure import _Fragment, wrap, Constant
from migen.fhdl.specials import Instance

from migen.build.generic_platform import *
from migen.build.xilinx.vivado import _build_xdc
from migen.build import tools


def _unwrap(value):
    return value.value if isinstance(value, Constant) else value


def _build_pcf(named_sc):
    r = ""
    current_resname = ""
    for sig, pins, _, resname in named_sc:
        if current_resname != resname[0]:
            if current_resname:
                r += "\n"
            current_resname = resname[0]
            r += f"# {current_resname}\n"
        if len(pins) > 1:
            for i, p in enumerate(pins):
                r += f"set_io {sig}[{i}] {Pins(p).identifiers[0]}\n"
        elif pins:
            r += f"set_io {sig} {Pins(pins[0]).identifiers[0]}\n"
    return r


def _build_sdc(named_pc):
    return "\n".join(named_pc) if named_pc else ""


try:
    import colorama
    colorama.init()  # install escape sequence translation on Windows
    _have_colorama = True
except ImportError:
    _have_colorama = False

colors = []
if _have_colorama:
    colors += [
        ("^(Error( [0-9]+)?:|.*: ERROR: ).*$", colorama.Fore.RED + colorama.Style.BRIGHT +
         r"\g<0>" + colorama.Style.RESET_ALL),
        ("^(Warning( [0-9]+)?:|.*: WARNING: ).*$", colorama.Fore.YELLOW +
         r"\g<0>" + colorama.Style.RESET_ALL),
    ]

def _run_script(build_name):
    if sys.platform == "win32" or sys.platform == "cygwin":
        # TODO: add support for Windows
        raise NotImplementedError("Windows support is not implemented")
    else:
        command = ["sh", f"build_{build_name}.sh"]
        r = tools.subprocess_call_filtered(command, colors, stderr=subprocess.STDOUT)
        if r != 0:
            raise OSError("Subprocess failed")


class SymbiflowToolchain:
    attr_translate = {
        "keep":            ("dont_touch", "true"),
        "no_retiming":     ("dont_touch", "true"),
        "async_reg":       ("async_reg",  "true"),
        "mr_ff":           ("mr_ff",      "true"), # user-defined attribute
        "ars_ff1":         ("ars_ff1",    "true"), # user-defined attribute
        "ars_ff2":         ("ars_ff2",    "true"), # user-defined attribute
        "no_shreg_extract": None
    }

    def __init__(self):
        self.clocks = dict()
        self.false_paths = set()

    def __setattr__(self, name, value):
        if name in ["bitstream_commands", "additional_commands", "pre_synthesis_commands", "with_phys_opt"]:
            warnings.warn(f"'{name}' is not supported by Symbiflow toolchain.", Warning, stacklevel=2)
        else:
            object.__setattr__(self, name, value)

    def _generate_build_script(self, platform, bitstream_device, sources, build_name):
        if sys.platform == "win32" or sys.platform == "cygwin":
            # TODO: add support for Windows
            raise NotImplementedError("Windows support is not implemented")

        sh = [
            "#!/bin/sh",
            "# Autogenerated by Migen",
            "set -ex", # stop execution when any command fail (e); print each command to stderr (x)
        ]
        escaped_sources = " ".join([shlex.quote(f) for f,language,_ in sources if language in ["verilog", "system_verilog"]])
        sh.append(f"symbiflow_synth -t {build_name} -v {escaped_sources} -d {bitstream_device} -p {platform.device} -x {build_name}.xdc")
        sh.append(f"symbiflow_pack -e {build_name}.eblif -P {platform.device} -s {build_name}.sdc")
        sh.append(f"symbiflow_place -e {build_name}.eblif -p {build_name}.pcf -n {build_name}.net -P {platform.device} -s {build_name}.sdc")
        sh.append(f"symbiflow_route -e {build_name}.eblif -P {platform.device} -s {build_name}.sdc")
        sh.append(f"symbiflow_write_fasm -e {build_name}.eblif -P {platform.device}")
        sh.append(f"symbiflow_write_bitstream -f {build_name}.fasm -d {bitstream_device} -p {platform.device} -b {build_name}.bit")
        tools.write_to_file(f"build_{build_name}.sh", "\n".join(sh) + "\n")

    def _build_clock_constraints(self, platform):
        for clk, period in sorted(self.clocks.items(), key=lambda x: x[0].duid):
            platform.add_platform_command(f"create_clock -period {period} {{clk}}", clk=clk)
        for from_, to in sorted(self.false_paths, key=lambda x: (x[0].duid, x[1].duid)):
            platform.add_platform_command("set_clock_groups -exclusive -group {{{from_}}} -group {{{to}}}", from_=from_, to=to)
        # Make sure add_*_constraint cannot be used again
        del self.clocks
        del self.false_paths

    # Yosys has limited support for real type. It requires that some values be multiplied
    # by 1000 and passed as integers. For details, see:
    # https://github.com/SymbiFlow/symbiflow-arch-defs/blob/master/xc/xc7/techmap/cells_map.v
    def _fix_instance(self, instance):
        if instance.of == "PLLE2_ADV":
            for item in instance.items:
                if isinstance(item, Instance.Parameter) and re.fullmatch("CLKOUT[0-9]_(PHASE|DUTY_CYCLE)", item.name):
                    item.value = wrap(math.floor(_unwrap(item.value) * 1000))

    def build(self, platform, fragment,
            build_dir  = "build",
            build_name = "top",
            run        = True,
            **kwargs):

        # Create build directory
        os.makedirs(build_dir, exist_ok=True)
        cwd = os.getcwd()
        os.chdir(build_dir)

        # Finalize design
        if not isinstance(fragment, _Fragment):
            fragment = fragment.get_fragment()
        platform.finalize(fragment)

        # Symbiflow-specific fixes
        for instance in fragment.specials:
            if isinstance(instance, Instance):
                self._fix_instance(instance)

        # Generate timing constraints
        self._build_clock_constraints(platform)

        # Generate verilog
        v_output = platform.get_verilog(fragment, name=build_name, **kwargs)
        named_sc, named_pc = platform.resolve_signals(v_output.ns)
        v_file = build_name + ".v"
        v_output.write(v_file)
        sources = platform.copy_sources(build_dir) | {(v_file, "verilog", "work")}

        if platform.device[3] == 'a':
            bitstream_device = 'artix7'
        elif platform.device[3] == 'k':
            bitstream_device = 'kintex7'
        elif platform.device[3] == 'z':
            bitstream_device = 'zynq7'
        else:
            raise Exception('Unknown bitstream device')

        self._generate_build_script(
            platform   = platform,
            bitstream_device = bitstream_device,
            sources    = sources,
            build_name = build_name
        )

        sdc_commands = [
            "create_clock",
            "set_clock_groups",
            "set_false_path",
            "set_max_delay", "set_min_delay",
            "set_multicycle_path",
            "set_input_delay", "set_output_delay",
            "set_clock_uncertainty",
            "set_clock_latency",
            "set_disable_timing"
        ]
        named_pc_xdc = []
        named_pc_sdc = []
        for pc in named_pc:
            cmd = pc.split(maxsplit=1)[0]
            if cmd in sdc_commands:
                named_pc_sdc.append(pc)
            else:
                named_pc_xdc.append(pc)

        # Generate design constraints
        tools.write_to_file(build_name + ".xdc", _build_xdc(named_sc, named_pc_xdc))
        tools.write_to_file(build_name + ".pcf", _build_pcf(named_sc))
        tools.write_to_file(build_name + ".sdc", _build_sdc(named_pc_sdc))

        if run:
            _run_script(build_name)

        os.chdir(cwd)

        return v_output.ns

    def add_period_constraint(self, platform, clk, period):
        if clk in self.clocks:
            raise ValueError("A period constraint already exists")
        self.clocks[clk] = period

    def add_false_path_constraint(self, platform, from_, to):
        if (from_, to) in self.false_paths or (to, from_) in self.false_paths:
            return
        self.false_paths.add((from_, to))
