#
# This file is part of LitePCIe.
#
# Copyright (c) 2015-2022 Florent Kermarrec <florent@enjoy-digital.fr>
# SPDX-License-Identifier: BSD-2-Clause

# In this high level test, LitePCIeEndpoint is connected to LitePCIeDMAReader and LitePCIeDMAWriter
# frontends with Reader's source connected to Writer's sink. Our Host model is used to emulate a Host
# memory with the Reader and Writer are reading/writing data from/to this memory.
#
#                                       ┌───────────┐
#                                       │           │
#                                       │   HOST    │
#                                       │  (Model)  │
#                                       │           │
#                                       └─┬───────▲─┘
#                                         │       │
#                                   ┌─────▼───────┴─────┐
#                                   │                   │
#                                   │                   │
#                                ┌──►  LitePCIeEndpoint ├─┐
#                                │  │                   │ │
#                                │  │                   │ │
#                                │  └───────────────────┘ │
#                                │                        │
#                       ┌────────┴──────────┐   ┌─────────▼─────────┐
#                       │                   │   │                   │
#                       │ LitePCIeDMAWriter │   │ LitePCIeDMAReader │
#                       │                   │   │                   │
#                       └────────▲──────────┘   └─────────┬─────────┘
#                                │                        │
#                                │                        │
#                                └────────────────────────┘
#
# The Host memory  is initially filled with random data, that are read by the Reader, re-directed
# to the Writer and then re-written in another memory location of the Host. The test then checks
# that the initial data and re-written data are identical.

import unittest

from litepcie.common import *
from litepcie.core import LitePCIeEndpoint
from litepcie.core.msi import LitePCIeMSI
from litepcie.frontend.dma import LitePCIeDMAWriter, LitePCIeDMAReader

from test.common import seed_to_data
from test.model.host import *

# Parameters ---------------------------------------------------------------------------------------

root_id     = 0x100
endpoint_id = 0x400

# DMA Driver ---------------------------------------------------------------------------------------

class DMADriver:
    """DMA Driver model

    Provides methods to control/program LitePCIeDMAReader/LitePCIeDMAWriter.
    """
    def __init__(self, dma, dut):
        self.dma = getattr(dut, dma)
        self.dut = dut

    def set_prog_mode(self):
        yield from self.dma.table.loop_prog_n.write(0)

    def set_loop_mode(self):
        yield from self.dma.table.loop_prog_n.write(1)

    def flush(self):
        yield from self.dma.table.reset.write(1)

    def program_descriptor(self, address, length):
        value = address
        value |= (length << self.dut.address_width)
        yield from self.dma.table.value.write(value)
        yield from self.dma.table.we.write(1)

    def enable(self):
        yield from self.dma._enable.write(1)

    def disable(self):
        yield from self.dma._enable.write(0)

# MSI Handler --------------------------------------------------------------------------------------

DMA_READER_IRQ = 1
DMA_WRITER_IRQ = 2

class MSIHandler(Module):
    """MSI Handled model

    Handles the MSI IRQs generated by LitePCIeDMAReader/LitePCIeDMAWriter.
    """
    def __init__(self, debug=False):
        self.debug = debug
        self.sink  = stream.Endpoint(msi_layout())

        self.dma_reader_irq_count = 0
        self.dma_writer_irq_count = 0

    def clear_dma_reader_irq_count(self):
        self.dma_reader_irq_count = 0

    def clear_dma_writer_irq_count(self):
        self.dma_writer_irq_count = 0

    @passive
    def generator(self, dut):
        while True:
            yield self.sink.ready.eq(1)
            if (yield self.sink.valid):
                # Get IRQs.
                irq_vector = (yield dut.msi.vector.status)
                irq_clear  = 0

                # Handle IRQs.
                if irq_vector & DMA_READER_IRQ:
                    self.dma_reader_irq_count += 1
                    if self.debug:
                        print("[MSI] dma_reader_irq (n: {:d})".format(self.dma_reader_irq_count))
                    irq_clear |= DMA_READER_IRQ

                if irq_vector & DMA_WRITER_IRQ:
                    self.dma_writer_irq_count += 1
                    if self.debug:
                        print("[MSI] dma_writer_irq (n: {:d})".format(self.dma_writer_irq_count))
                    irq_clear |= DMA_WRITER_IRQ
                # Clear IRQs.
                yield from dut.msi.clear.write((yield from dut.msi.clear.read()) | irq_clear)
            yield

# Test DMA -----------------------------------------------------------------------------------------

class TestDMA(unittest.TestCase):
    def dma_test(self, data_width, address_width, test_size=1024):
        host_data     = [seed_to_data(i, True) for i in range(test_size//4)]
        loopback_data = []

        def main_generator(dut, nreads=8, nwrites=8):
            # Allocate Host's Memory.
            dut.host.malloc(0x00000000, test_size*2)

            # Enable Chipset
            dut.host.chipset.enable()

            # Fill initial Host's Memory.
            dut.host.write_mem(0x00000000, host_data)

            # DMA Reader/Writer control models.
            dma_reader_driver = DMADriver("dma_reader", dut)
            dma_writer_driver = DMADriver("dma_writer", dut)

            # Program DMA Reader descriptors.
            yield from dma_reader_driver.set_prog_mode()
            yield from dma_reader_driver.flush()
            for i in range(nreads):
                yield from dma_reader_driver.program_descriptor((test_size//8)*i, test_size//8)

            # Program DMA Writer descriptors.
            yield from dma_writer_driver.set_prog_mode()
            yield from dma_writer_driver.flush()
            for i in range(nwrites):
                yield from dma_writer_driver.program_descriptor(test_size + (test_size//8)*i, test_size//8)

            # Enable MSI.
            yield dut.msi.enable.storage.eq(DMA_READER_IRQ | DMA_WRITER_IRQ)

            # Enable DMA Reader & Writer.
            yield from dma_reader_driver.enable()
            yield from dma_writer_driver.enable()

            # Wait for all writes.
            while dut.msi_handler.dma_writer_irq_count != nwrites:
                yield

            # Delay to ensure all the data has been written.
            for i in range(1024):
                yield

            for data in dut.host.read_mem(test_size, test_size):
                loopback_data.append(data)


        class DUT(Module):
            def __init__(self, data_width, address_width):
                self.data_width    = data_width
                self.address_width = address_width

                # Host -----------------------------------------------------------------------------
                self.submodules.host = Host(data_width, root_id, endpoint_id,
                    phy_debug          = False,
                    chipset_debug      = False,
                    chipset_split      = True,
                    chipset_reordering = True,
                    host_debug         = True)

                # Endpoint -------------------------------------------------------------------------
                self.submodules.endpoint = LitePCIeEndpoint(self.host.phy,
                    address_width        = address_width,
                    max_pending_requests = 8
                )

                # DMA Reader/Writer ----------------------------------------------------------------
                dma_reader_port = self.endpoint.crossbar.get_master_port(read_only=True)
                dma_writer_port = self.endpoint.crossbar.get_master_port(write_only=True)
                self.submodules.dma_reader = LitePCIeDMAReader(self.endpoint, dma_reader_port, address_width=address_width)
                self.submodules.dma_writer = LitePCIeDMAWriter(self.endpoint, dma_writer_port, address_width=address_width)
                self.comb += self.dma_reader.source.connect(self.dma_writer.sink)

                # MSI ------------------------------------------------------------------------------
                self.submodules.msi = LitePCIeMSI(2)
                self.comb += [
                    self.msi.irqs[log2_int(DMA_READER_IRQ)].eq(self.dma_reader.irq),
                    self.msi.irqs[log2_int(DMA_WRITER_IRQ)].eq(self.dma_writer.irq)
                ]
                self.submodules.msi_handler = MSIHandler(debug=False)
                self.comb += self.msi.source.connect(self.msi_handler.sink)

        dut = DUT(data_width, address_width)
        generators = {
            "sys" : [
                main_generator(dut),
                dut.msi_handler.generator(dut),
                dut.host.generator(),
                dut.host.chipset.generator(),
                dut.host.phy.phy_sink.generator(),
                dut.host.phy.phy_source.generator()
            ]
        }
        clocks = {"sys": 10}
        run_simulation(dut, generators, clocks, vcd_name="test_dma.vcd")
        self.assertEqual(host_data, loopback_data)

    def test_dma_64b_data_width_32b_address_width(self):
        self.dma_test(data_width=64, address_width=32)

    def test_dma_64b_data_width_64b_address_width(self):
        self.dma_test(data_width=64, address_width=64)